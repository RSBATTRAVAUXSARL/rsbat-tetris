<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
<title>RS-BAT • Tetris Construction</title>
<style>
  :root{
    --bg:#0b0f14;
    --panel:#111824;
    --text:#e6eefc;
    --muted:#9fb2d6;
    --blue:#1e4fa3;     /* RS-BAT blue (approx) */
    --yellow:#f2b705;   /* RS-BAT yellow (approx) */
    --shadow: rgba(0,0,0,.42);
    --stroke: rgba(255,255,255,.10);
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0;
    color:var(--text);
    font: 14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Arial;
    display:flex;
    align-items:center;
    justify-content:center;
    padding:18px;
    background: radial-gradient(1200px 800px at 30% 10%, rgba(30,79,163,.35) 0%, rgba(11,15,20,1) 60%);
    overflow:hidden;
    touch-action: manipulation;
  }

  /* Pixel chantier background */
  #bg{
    position:fixed; inset:0;
    width:100vw; height:100vh;
    z-index:-2;
    image-rendering: pixelated;
    filter: blur(10px) saturate(1.05);
    opacity:.38;
    transform: scale(1.03);
  }
  .vignette{
    position:fixed; inset:-2px;
    z-index:-1;
    background: radial-gradient(900px 700px at 20% 0%, rgba(30,79,163,.35), transparent 60%),
                radial-gradient(900px 700px at 80% 10%, rgba(242,183,5,.12), transparent 58%),
                radial-gradient(900px 900px at 50% 85%, rgba(0,0,0,.55), transparent 65%);
    pointer-events:none;
  }

  .wrap{
    display:grid;
    gap:14px;
    grid-template-columns: 360px 240px;
    align-items:start;
    max-width: 980px;
    width:min(980px, 100%);
  }

  .card{
    background: linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.02));
    border:1px solid rgba(255,255,255,.08);
    border-radius:16px;
    box-shadow: 0 18px 45px var(--shadow);
    overflow:hidden;
    backdrop-filter: blur(3px);
  }

  .topbar{
    display:flex;
    align-items:center;
    justify-content:space-between;
    padding:12px 14px;
    border-bottom:1px solid rgba(255,255,255,.08);
    background: rgba(0,0,0,.22);
  }

  .brand{
    display:flex; align-items:center; gap:10px;
    font-weight:800;
    letter-spacing:.2px;
  }
  .brand small{font-weight:700; color:var(--muted)}
  .dot{
    width:10px; height:10px; border-radius:50%;
    background: var(--blue);
    box-shadow: 0 0 0 4px rgba(30,79,163,.20);
    position:relative;
  }
  .dot:after{
    content:"";
    position:absolute;
    width:5px;height:5px;border-radius:50%;
    right:-2px; bottom:-2px;
    background: var(--yellow);
    box-shadow: 0 0 0 3px rgba(242,183,5,.16);
  }

  .kbd{
    display:inline-flex; align-items:center; justify-content:center;
    padding:2px 6px; border-radius:8px;
    border:1px solid rgba(255,255,255,.18);
    background: rgba(0,0,0,.25);
    color: var(--text);
    font-size:12px;
    margin-left:6px;
  }

  canvas{ display:block; width:100%; height:auto; background:#060a10; }

  .side{
    padding:14px;
    display:flex;
    flex-direction:column;
    gap:12px;
  }

  .stat{
    display:flex;
    justify-content:space-between;
    gap:10px;
    padding:10px 12px;
    border-radius:12px;
    background: rgba(0,0,0,.22);
    border:1px solid rgba(255,255,255,.08);
  }
  .stat b{font-size:16px}
  .muted{color:var(--muted)}
  .small{font-size:12px}

  .row{
    display:flex; gap:10px; align-items:center; justify-content:space-between;
  }
  .pseudoWrap{
    display:flex; gap:10px; align-items:center;
  }
  input[type="text"]{
    width:100%;
    padding:10px 10px;
    border-radius:12px;
    border:1px solid rgba(255,255,255,.14);
    background: rgba(0,0,0,.28);
    color:var(--text);
    outline:none;
  }
  input[type="text"]:focus{ border-color: rgba(242,183,5,.45); }
  .pill{
    display:inline-flex;
    align-items:center;
    gap:8px;
    padding:8px 10px;
    border-radius:12px;
    border:1px solid rgba(255,255,255,.14);
    background: rgba(0,0,0,.28);
    font-weight:800;
    cursor:pointer;
    user-select:none;
    white-space:nowrap;
  }
  .pill:hover{ border-color: rgba(30,79,163,.55); }
  .pill .ok{
    width:8px;height:8px;border-radius:50%;
    background: var(--yellow);
    box-shadow: 0 0 0 4px rgba(242,183,5,.16);
  }

  .btns{ display:flex; gap:10px; }
  button{
    flex:1;
    padding:10px 12px;
    border-radius:12px;
    border:1px solid rgba(255,255,255,.14);
    background: rgba(0,0,0,.28);
    color:var(--text);
    font-weight:900;
    cursor:pointer;
  }
  button:hover{ border-color: rgba(242,183,5,.40); }

  .hint{
    padding:10px 12px;
    border-radius:12px;
    background: rgba(0,0,0,.18);
    border:1px solid rgba(255,255,255,.08);
    color: var(--muted);
  }
  .danger{ color:#ff6a6a; font-weight:900; }

  /* Mobile controls */
  .touchControls{
    display:none;
    gap:10px;
    padding:10px 12px;
    border-radius:12px;
    background: rgba(0,0,0,.18);
    border:1px solid rgba(255,255,255,.08);
  }
  .touchControls button{
    padding:12px 10px;
    font-size:14px;
    border-color: rgba(255,255,255,.12);
  }
  .touchControls button.primary{
    border-color: rgba(242,183,5,.35);
  }

  @media (max-width: 760px){
    body{padding:12px}
    .wrap{grid-template-columns: 1fr; justify-items:center}
    .wrap > .card{width:min(420px, 100%)}
  }
  @media (hover:none) and (pointer:coarse){
    .touchControls{display:flex}
  }
</style>
</head>

<body>
<canvas id="bg"></canvas>
<div class="vignette"></div>

<div class="wrap">
  <!-- GAME -->
  <div class="card">
    <div class="topbar">
      <div class="brand">
        <span class="dot"></span>
        RS-BAT • Tetris Construction <small>pixel</small>
      </div>
      <div class="muted small">
        Pause <span class="kbd">P</span> • Restart <span class="kbd">R</span>
      </div>
    </div>
    <canvas id="game" width="360" height="720"></canvas>
  </div>

  <!-- SIDE -->
  <div class="card">
    <div class="topbar">
      <div class="brand"><span class="dot"></span> Console</div>
      <div class="muted small">v1.0</div>
    </div>
    <div class="side">
      <div class="row">
        <div class="pseudoWrap" style="flex:1;">
          <input id="pseudo" type="text" placeholder="Pseudo (optionnel)" autocomplete="off" spellcheck="false" />
          <div id="btnValidate" class="pill"><span class="ok"></span><span>Valider</span></div>
        </div>
      </div>

      <div class="stat"><span class="muted">Score</span><b id="score">0</b></div>
      <div class="stat"><span class="muted">Lignes</span><b id="lines">0</b></div>
      <div class="stat"><span class="muted">Niveau</span><b id="level">1</b></div>

      <div class="stat" style="align-items:center;">
        <div style="width:100%">
          <div class="muted small">Prochaine pièce</div>
          <canvas id="next" width="120" height="120" style="width:120px;height:120px;border-radius:12px; margin-top:6px; background:#060a10; border:1px solid rgba(255,255,255,.08)"></canvas>
        </div>
      </div>

      <div class="btns">
        <button id="btnPause">Pause</button>
        <button id="btnRestart">Restart</button>
      </div>

      <div class="touchControls" id="touchControls">
        <button id="tLeft">←</button>
        <button id="tRotate" class="primary">⟳</button>
        <button id="tRight">→</button>
        <button id="tDown">↓</button>
        <button id="tDrop" class="primary">⤓</button>
      </div>

      <div class="hint">
        <div><b>Contrôles</b></div>
        <div class="small">
          ← → : déplacer<br/>
          ↓ : descendre<br/>
          ↑ : rotation<br/>
          Espace : drop<br/>
          P : pause • R : restart
        </div>
      </div>

      <div class="hint small" id="blabla">
        Empile des éléments de chantier et complète des lignes pour stabiliser la structure.
        <div style="margin-top:6px" class="muted small">Astuce : enchaîne les “4 lignes” pour maximiser le score.</div>
      </div>

      <div id="status" class="hint small muted">Prêt.</div>
    </div>
  </div>
</div>

<script>
(() => {
  /* =========================================================
     PIXEL BACKGROUND (ville + grue + malaxeur + barrières)
     ========================================================= */
  const bg = document.getElementById('bg');
  const bctx = bg.getContext('2d', { alpha: true });

  function resizeBG(){
    bg.width = Math.floor(window.innerWidth / 2);
    bg.height = Math.floor(window.innerHeight / 2);
  }
  resizeBG();
  window.addEventListener('resize', resizeBG);

  function px(c,x,y,w,h){ c.fillRect(x|0,y|0,w|0,h|0); }

  function drawPixelCity(t){
    const W = bg.width, H = bg.height;
    bctx.clearRect(0,0,W,H);

    // sky gradient
    const g = bctx.createLinearGradient(0,0,0,H);
    g.addColorStop(0, 'rgba(12,18,28,1)');
    g.addColorStop(1, 'rgba(6,10,16,1)');
    bctx.fillStyle = g; px(bctx,0,0,W,H);

    // subtle stars
    bctx.fillStyle = 'rgba(220,235,255,.12)';
    for(let i=0;i<60;i++){
      const sx = (Math.sin(i*999 + t*0.0002)+1)*0.5*W;
      const sy = (Math.cos(i*777 + t*0.00015)+1)*0.5*H*0.35;
      px(bctx, sx, sy, 1, 1);
    }

    // distant city blocks
    function buildingLayer(yBase, amp, colorA, colorB, win){
      for(let x=0;x<W;x+=8){
        const h = 10 + ((Math.sin((x*0.11) + (t*0.0003))*0.5+0.5)*amp)|0;
        bctx.fillStyle = (x%16===0)?colorA:colorB;
        px(bctx,x, yBase-h, 8, h);
        // windows
        bctx.fillStyle = win;
        for(let yy=yBase-h+2; yy<yBase-2; yy+=4){
          if(((x+yy+t*0.01)|0)%3===0) px(bctx,x+2, yy, 1, 1);
          if(((x+yy+t*0.01)|0)%5===0) px(bctx,x+5, yy, 1, 1);
        }
      }
    }
    buildingLayer((H*0.62)|0, 22, 'rgba(20,30,46,1)','rgba(16,24,38,1)','rgba(242,183,5,.14)');
    buildingLayer((H*0.70)|0, 28, 'rgba(16,24,38,1)','rgba(12,18,28,1)','rgba(220,235,255,.10)');

    // ground
    bctx.fillStyle = 'rgba(10,14,20,1)';
    px(bctx,0,(H*0.72)|0,W,(H*0.28)|0);

    // chantier foreground silhouettes
    const groundY = (H*0.77)|0;

    // crane (RS-BAT yellow-ish)
    const craneX = (W*0.72 + Math.sin(t*0.0004)*3)|0;
    bctx.fillStyle = 'rgba(242,183,5,.55)';
    // mast
    px(bctx, craneX, groundY-90, 5, 90);
    // jib
    px(bctx, craneX-80, groundY-88, 85, 4);
    // hook line
    px(bctx, craneX-20, groundY-88, 2, 38);
    // hook block
    px(bctx, craneX-23, groundY-50, 8, 6);

    // mixer truck (malaxeur) on left
    const mx = (W*0.18 + Math.sin(t*0.0005)*2)|0;
    bctx.fillStyle = 'rgba(180,190,210,.45)';
    px(bctx, mx, groundY-18, 40, 12); // body
    bctx.fillStyle = 'rgba(30,40,60,.6)';
    px(bctx, mx+30, groundY-22, 10, 6); // cabin
    bctx.fillStyle = 'rgba(80,90,110,.55)';
    // drum
    px(bctx, mx+12, groundY-26, 18, 8);
    px(bctx, mx+14, groundY-28, 14, 4);
    // wheels
    bctx.fillStyle = 'rgba(0,0,0,.55)';
    px(bctx, mx+6, groundY-6, 6, 6);
    px(bctx, mx+28, groundY-6, 6, 6);

    // barriers (Heras vibe)
    bctx.fillStyle = 'rgba(60,140,210,.25)';
    for(let bx=0; bx<W; bx+=14){
      const y = groundY-10;
      px(bctx,bx,y,12,2);
      px(bctx,bx,y+6,12,2);
      px(bctx,bx+2,y-2,2,14);
      px(bctx,bx+10,y-2,2,14);
    }

    // hazard stripes plate
    bctx.fillStyle = 'rgba(242,183,5,.35)';
    px(bctx, (W*0.42)|0, groundY-16, 60, 10);
    bctx.fillStyle = 'rgba(0,0,0,.35)';
    for(let i=0;i<60;i+=8){
      px(bctx, ((W*0.42)|0)+i, groundY-16, 4, 10);
    }
  }

  let bgTime = 0;
  function bgLoop(t){
    bgTime = t;
    drawPixelCity(t);
    requestAnimationFrame(bgLoop);
  }
  requestAnimationFrame(bgLoop);

  /* =========================================================
     TETRIS CORE (stable)
     ========================================================= */
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const nextCanvas = document.getElementById('next');
  const nctx = nextCanvas.getContext('2d');

  const scoreEl = document.getElementById('score');
  const linesEl = document.getElementById('lines');
  const levelEl = document.getElementById('level');
  const statusEl = document.getElementById('status');

  const btnPause = document.getElementById('btnPause');
  const btnRestart = document.getElementById('btnRestart');

  const pseudoEl = document.getElementById('pseudo');
  const btnValidate = document.getElementById('btnValidate');

  // 10 x 22 (2 hidden rows)
  const COLS = 10;
  const ROWS = 22;
  const VISIBLE = 20;

  const CELL = Math.floor(canvas.width / COLS); // 36
  canvas.height = CELL * VISIBLE;

  let board, current, next, bag;
  let score = 0, lines = 0, level = 1;
  let dropCounter = 0, dropInterval = 850;
  let lastTime = 0;
  let paused = false, gameOver = false;

  // Secret modes (must remain invisible unless validated)
  let secretMode = "NONE"; // "NONE" | "LEONIS" | "LEONA"
  let leonaCharges = 0;

  // Shapes (classic)
  const SHAPES = {
    I: [
      [0,0,0,0],
      [1,1,1,1],
      [0,0,0,0],
      [0,0,0,0],
    ],
    O: [
      [1,1],
      [1,1],
    ],
    T: [
      [0,1,0],
      [1,1,1],
      [0,0,0],
    ],
    S: [
      [0,1,1],
      [1,1,0],
      [0,0,0],
    ],
    Z: [
      [1,1,0],
      [0,1,1],
      [0,0,0],
    ],
    J: [
      [1,0,0],
      [1,1,1],
      [0,0,0],
    ],
    L: [
      [0,0,1],
      [1,1,1],
      [0,0,0],
    ],
  };

  // Materials per piece (chantier)
  // MAIN REQUEST: coffrage + clous as dominant texture
  const MATERIAL = {
    I: 'REBAR',       // ferraillage / poutre
    O: 'FORMWORK',    // coffrage + clous
    T: 'FORMWORK',    // coffrage + clous
    S: 'CONCRETE',    // béton
    Z: 'STEEL',       // acier
    J: 'ASPHALT',     // enrobé (sol chantier)
    L: 'SIGN',        // signalisation (jaune/noir)
    // special block for LEONA beam:
    BEAM: 'BEAM'
  };

  function refillBag(){
    bag = Object.keys(SHAPES);
    for(let i=bag.length-1;i>0;i--){
      const j = (Math.random()*(i+1))|0;
      [bag[i], bag[j]] = [bag[j], bag[i]];
    }
  }
  function nextFromBag(){
    if(!bag || bag.length===0) refillBag();
    return bag.pop();
  }

  function makeBoard(){
    const b = [];
    for(let r=0;r<ROWS;r++) b.push(new Array(COLS).fill(null));
    return b;
  }

  function spawnPiece(type){
    const shape = SHAPES[type].map(r => r.slice());
    const x = Math.floor((COLS - shape[0].length)/2);
    const y = 0;
    return { type, shape, x, y };
  }

  function reset(){
    board = makeBoard();
    score = 0; lines = 0; level = 1;
    dropInterval = 850;
    paused = false;
    gameOver = false;
    dropCounter = 0;
    lastTime = 0;

    refillBag();
    current = spawnPiece(nextFromBag());
    next = spawnPiece(nextFromBag());

    // secret mode remains, but UI stays silent (no mention)
    if(secretMode === "LEONA"){
      leonaCharges = 2; // start small
    } else {
      leonaCharges = 0;
    }

    updateUI();
    statusEl.textContent = "RS-BAT vous souhaite de Bonne fêtes à tous";
  }

  function collide(b, p){
    const m = p.shape;
    for(let y=0; y<m.length; y++){
      for(let x=0; x<m[y].length; x++){
        if(m[y][x]){
          const bx = p.x + x;
          const by = p.y + y;
          if(bx < 0 || bx >= COLS || by >= ROWS) return true;
          if(by >= 0 && b[by][bx]) return true;
        }
      }
    }
    return false;
  }

  function merge(b, p){
    const m = p.shape;
    for(let y=0; y<m.length; y++){
      for(let x=0; x<m[y].length; x++){
        if(m[y][x]){
          const by = p.y + y;
          const bx = p.x + x;
          if(by >= 0 && by < ROWS && bx >= 0 && bx < COLS){
            b[by][bx] = p.type;
          }
        }
      }
    }
  }

  const LINE_SCORES = [0, 100, 300, 500, 800];
  function sweep(){
    let rowCount = 0;
    outer: for(let y=0; y<ROWS; y++){
      for(let x=0; x<COLS; x++){
        if(!board[y][x]) continue outer;
      }
      const row = board.splice(y, 1)[0].fill(null);
      board.unshift(row);
      rowCount++;
    }
    if(rowCount>0){
      lines += rowCount;
      score += LINE_SCORES[rowCount] * level;

      // LEONA recharge on clears (still invisible)
      if(secretMode === "LEONA"){
        leonaCharges = Math.min(6, leonaCharges + rowCount);
      }

      const newLevel = Math.floor(lines / 10) + 1;
      if(newLevel !== level){
        level = newLevel;
        dropInterval = Math.max(90, 850 - (level-1)*65);
      }

      statusEl.textContent = (rowCount===4) ? "Excellent ✅" : `Lignes +${rowCount}`;
      updateUI();
      // line clear flash
      flashOverlay(180, "rgba(242,183,5,.08)");
    }
  }

  function rotate(matrix, dir){
    const m = matrix.map(r => r.slice());
    for(let y=0;y<m.length;y++){
      for(let x=0;x<y;x++){
        [m[x][y], m[y][x]] = [m[y][x], m[x][y]];
      }
    }
    if(dir>0) m.forEach(r => r.reverse());
    else m.reverse();
    return m;
  }

  function tryRotate(dir){
    const old = current.shape;
    const rotated = rotate(old, dir);
    const oldX = current.x;
    current.shape = rotated;

    const kicks = [0,-1,1,-2,2];
    for(const k of kicks){
      current.x = oldX + k;
      if(!collide(board, current)) return true;
    }
    current.x = oldX;
    current.shape = old;
    return false;
  }

  function hardDrop(){
    if(gameOver || paused) return;
    let dist = 0;
    while(true){
      current.y++;
      if(collide(board, current)){
        current.y--;
        break;
      }
      dist++;
    }
    score += Math.max(0, dist * 2);
    lockPiece();
  }

  function softDrop(){
    if(gameOver || paused) return;
    current.y++;
    if(collide(board, current)){
      current.y--;
      lockPiece();
    } else {
      score += 1;
    }
    updateUI();
  }

  function lockPiece(){
    merge(board, current);
    sweep();

    current = next;
    next = spawnPiece(nextFromBag());

    if(collide(board, current)){
      gameOver = true;
      // “Fin de chantier” screen (no "Game Over" harsh)
      statusEl.innerHTML = `<span class="danger">Chantier terminé.</span> Appuie sur R.`;
      confettiBurst();
    }
    updateUI();
  }

  /* =========================================================
     DRAWING (grid + pixel textures)
     ========================================================= */
  function clear(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
  }

  function drawGrid(){
    ctx.save();
    ctx.globalAlpha = 1;
    ctx.fillStyle = "#060a10";
    ctx.fillRect(0,0,canvas.width,canvas.height);

    // full grid (V1)
    ctx.globalAlpha = 0.10;
    ctx.strokeStyle = "#ffffff";
    ctx.lineWidth = 1;
    for(let x=0;x<=COLS;x++){
      ctx.beginPath();
      ctx.moveTo(x*CELL+0.5,0);
      ctx.lineTo(x*CELL+0.5,canvas.height);
      ctx.stroke();
    }
    for(let y=0;y<=VISIBLE;y++){
      ctx.beginPath();
      ctx.moveTo(0,y*CELL+0.5);
      ctx.lineTo(canvas.width,y*CELL+0.5);
      ctx.stroke();
    }
    ctx.restore();
  }

  function drawBoard(){
    drawGrid();

    for(let y=0;y<ROWS;y++){
      for(let x=0;x<COLS;x++){
        const t = board[y][x];
        if(!t) continue;
        const vy = y - (ROWS - VISIBLE);
        if(vy>=0){
          drawTile(ctx, x*CELL, vy*CELL, CELL, MATERIAL[t] || 'FORMWORK', 1);
        }
      }
    }
  }

  function drawPiece(p, ghost=false){
    const m = p.shape;
    for(let y=0;y<m.length;y++){
      for(let x=0;x<m[y].length;x++){
        if(!m[y][x]) continue;
        const bx = p.x + x;
        const by = p.y + y;
        const vy = by - (ROWS - VISIBLE);
        if(vy>=0){
          drawTile(ctx, bx*CELL, vy*CELL, CELL, MATERIAL[p.type], ghost?0.30:1);
        }
      }
    }
  }

  function computeGhost(){
    const g = { type: current.type, shape: current.shape, x: current.x, y: current.y };
    while(true){
      g.y++;
      if(collide(board, g)){ g.y--; return g; }
    }
  }

  // Simple particles for break/impact
  const particles = [];
  function spawnParticles(px, py, color){
    for(let i=0;i<16;i++){
      particles.push({
        x:px + (Math.random()*CELL),
        y:py + (Math.random()*CELL),
        vx:(Math.random()*2-1)*2.2,
        vy:(Math.random()*2-1)*2.2 - 1.4,
        life: 450 + Math.random()*280,
        born: performance.now(),
        color
      });
    }
  }
  function drawParticles(now){
    for(let i=particles.length-1;i>=0;i--){
      const p = particles[i];
      const age = now - p.born;
      if(age > p.life){ particles.splice(i,1); continue; }
      const k = 1 - (age/p.life);
      p.x += p.vx;
      p.y += p.vy;
      p.vy += 0.03; // gravity
      ctx.save();
      ctx.globalAlpha = 0.65 * k;
      ctx.fillStyle = p.color;
      ctx.fillRect(p.x|0, p.y|0, 2, 2);
      ctx.restore();
    }
  }

  // overlay flash
  let overlayUntil = 0;
  let overlayColor = "rgba(242,183,5,.06)";
  function flashOverlay(ms, color){
    overlayUntil = performance.now() + ms;
    overlayColor = color;
  }

  // Confetti (end)
  const confetti = [];
  function confettiBurst(){
    const now = performance.now();
    for(let i=0;i<110;i++){
      confetti.push({
        x: canvas.width/2,
        y: canvas.height/2,
        vx:(Math.random()*2-1)*3.8,
        vy:(Math.random()*2-1)*3.8 - 2.2,
        life: 1200 + Math.random()*900,
        born: now,
        c: (i%3===0) ? "rgba(242,183,5,.9)" : (i%3===1) ? "rgba(30,79,163,.9)" : "rgba(230,238,252,.8)"
      });
    }
  }
  function drawConfetti(now){
    for(let i=confetti.length-1;i>=0;i--){
      const p = confetti[i];
      const age = now - p.born;
      if(age>p.life){ confetti.splice(i,1); continue; }
      const k = 1 - age/p.life;
      p.x += p.vx; p.y += p.vy;
      p.vy += 0.05;
      ctx.save();
      ctx.globalAlpha = 0.65*k;
      ctx.fillStyle = p.c;
      ctx.fillRect(p.x|0, p.y|0, 2, 3);
      ctx.restore();
    }
  }

  // Pixel tile renderer (construction textures)
  function drawTile(c, px, py, size, material, alpha=1){
    c.save();
    c.globalAlpha = alpha;

    const pad = 1;
    const s = size - pad*2;

    // palettes
    const PAL = {
      FORMWORK: ["#b5844d","#6e4c2b","#e2c08d","#8a5f35"], // wood plank
      CONCRETE: ["#8e97a6","#5f6a79","#c2cbd8","#6e7784"], // concrete
      STEEL:    ["#7ea3b8","#456676","#b9d8e6","#5b7c8d"], // steel
      REBAR:    ["#5f6a79","#2f3642","#9fb2d6","#3a4250"], // rebar dark steel
      ASPHALT:  ["#343a42","#1f2328","#646b75","#2a2f36"],
      SIGN:     ["#f2b705","#9a6f00","#ffe38f","#000000"],
      BEAM:     ["#f2b705","#9a6f00","#ffe38f","#1e4fa3"],
    };
    const p = PAL[material] || PAL.FORMWORK;
    const [base,dark,light,detail] = p;

    // base + bevel
    c.fillStyle = base; c.fillRect(px+pad, py+pad, s, s);
    c.globalAlpha = alpha*0.9;
    c.fillStyle = light; c.fillRect(px+pad, py+pad, s, 2); c.fillRect(px+pad, py+pad, 2, s);
    c.fillStyle = dark; c.fillRect(px+pad, py+pad+s-2, s, 2); c.fillRect(px+pad+s-2, py+pad, 2, s);
    c.globalAlpha = alpha;

    const g = (n)=>Math.max(1, Math.floor(size/n));

    if(material === "FORMWORK"){
      // wood grain
      c.globalAlpha = alpha*0.55;
      c.fillStyle = detail;
      const step = g(7);
      for(let yy=2; yy<s-2; yy+=step){
        c.fillRect(px+pad+2, py+pad+yy, s-4, 1);
      }
      // plank seams (vertical)
      c.globalAlpha = alpha*0.25;
      c.fillStyle = "#000000";
      c.fillRect(px+pad+Math.floor(s*0.33), py+pad+2, 1, s-4);
      c.fillRect(px+pad+Math.floor(s*0.66), py+pad+2, 1, s-4);

      // nails (small dots)
      c.globalAlpha = alpha*0.85;
      c.fillStyle = "rgba(30,40,60,.85)";
      const nx = [Math.floor(s*0.22), Math.floor(s*0.78)];
      const ny = [Math.floor(s*0.22), Math.floor(s*0.78)];
      for(const ax of nx){
        for(const ay of ny){
          c.fillRect(px+pad+ax, py+pad+ay, 1, 1);
          c.fillRect(px+pad+ax+1, py+pad+ay, 1, 1);
        }
      }
      c.globalAlpha = alpha;
    }
    else if(material === "REBAR"){
      // rebar ribs
      c.globalAlpha = alpha*0.55;
      c.fillStyle = light;
      for(let yy=2; yy<s-2; yy+=g(6)){
        c.fillRect(px+pad+2, py+pad+yy, s-4, 1);
      }
      c.globalAlpha = alpha*0.35;
      c.fillStyle = detail;
      c.fillRect(px+pad+Math.floor(s*0.5), py+pad+2, 1, s-4);
      c.globalAlpha = alpha;
    }
    else if(material === "CONCRETE"){
      c.fillStyle = detail;
      for(let i=0;i<10;i++){
        const x = px+pad + ((Math.random()*s)|0);
        const y = py+pad + ((Math.random()*s)|0);
        c.fillRect(x,y,1,1);
      }
      c.globalAlpha = alpha*0.35;
      c.fillStyle = "rgba(255,255,255,.65)";
      c.fillRect(px+pad+2, py+pad+Math.floor(s/2), s-4, 1);
      c.globalAlpha = alpha;
    }
    else if(material === "STEEL"){
      c.globalAlpha = alpha*0.55;
      c.fillStyle = "rgba(255,255,255,.75)";
      c.fillRect(px+pad+2, py+pad+3, s-4, 1);
      c.fillRect(px+pad+2, py+pad+Math.floor(s/2), s-4, 1);
      c.globalAlpha = alpha*0.25;
      c.fillStyle = detail;
      c.fillRect(px+pad+Math.floor(s*0.65), py+pad+2, 1, s-4);
      c.globalAlpha = alpha;
    }
    else if(material === "ASPHALT"){
      c.fillStyle = detail;
      for(let i=0;i<14;i++){
        const x = px+pad + ((Math.random()*s)|0);
        const y = py+pad + ((Math.random()*s)|0);
        c.fillRect(x,y,1,1);
      }
      c.globalAlpha = alpha*0.35;
      c.fillStyle = "rgba(242,183,5,.75)";
      c.fillRect(px+pad+Math.floor(s/2), py+pad+2, 1, s-4);
      c.globalAlpha = alpha;
    }
    else if(material === "SIGN"){
      // yellow/black stripes
      c.save();
      c.beginPath(); c.rect(px+pad, py+pad, s, s); c.clip();
      c.translate(px+pad, py+pad);
      c.rotate(-Math.PI/4);
      c.fillStyle = "rgba(0,0,0,.55)";
      const stripe = Math.max(3, g(4));
      for(let y=-s*2; y<s*2; y+=stripe*2){
        c.fillRect(-s*2, y, s*4, stripe);
      }
      c.restore();
      // border
      c.strokeStyle = "rgba(0,0,0,.55)";
      c.lineWidth = 2;
      c.strokeRect(px+pad+1, py+pad+1, s-2, s-2);
    }
    else if(material === "BEAM"){
      // “poutre” (LEONA): yellow beam with blue rivets
      c.globalAlpha = alpha*0.85;
      c.fillStyle = "rgba(30,79,163,.65)";
      c.fillRect(px+pad+3, py+pad+3, s-6, 1);
      c.fillRect(px+pad+3, py+pad+s-4, s-6, 1);
      c.globalAlpha = alpha;
      c.fillStyle = "rgba(30,79,163,.85)";
      c.fillRect(px+pad+Math.floor(s*0.25), py+pad+Math.floor(s*0.25), 2, 2);
      c.fillRect(px+pad+Math.floor(s*0.70), py+pad+Math.floor(s*0.70), 2, 2);
    }

    // crisp border
    c.globalAlpha = alpha;
    c.strokeStyle = "rgba(255,255,255,.10)";
    c.lineWidth = 1;
    c.strokeRect(px+0.5, py+0.5, size-1, size-1);
    c.restore();
  }

  function drawNext(){
    nctx.clearRect(0,0,nextCanvas.width,nextCanvas.height);
    nctx.fillStyle = "#060a10";
    nctx.fillRect(0,0,nextCanvas.width,nextCanvas.height);

    const shape = next.shape;
    const tile = 24;
    const w = shape[0].length * tile;
    const h = shape.length * tile;
    const ox = Math.floor((nextCanvas.width - w)/2);
    const oy = Math.floor((nextCanvas.height - h)/2);

    for(let y=0;y<shape.length;y++){
      for(let x=0;x<shape[y].length;x++){
        if(shape[y][x]){
          drawTile(nctx, ox + x*tile, oy + y*tile, tile, MATERIAL[next.type], 1);
        }
      }
    }
  }

  function updateUI(){
    scoreEl.textContent = score|0;
    linesEl.textContent = lines|0;
    levelEl.textContent = level|0;
    drawNext();
  }

  /* =========================================================
     SECRET MODES (hidden)
     - LEONIS: long-press on board to break one locked block
     - LEONA : long-press on empty cell to place a beam (limited)
     No UI mention, no controls mention.
     ========================================================= */
  function isInsideVisibleBoard(px, py){
    return px>=0 && px<canvas.width && py>=0 && py<canvas.height;
  }
  function screenToCell(px, py){
    const rect = canvas.getBoundingClientRect();
    const x = (px - rect.left) * (canvas.width / rect.width);
    const y = (py - rect.top) * (canvas.height / rect.height);
    const cx = Math.floor(x / CELL);
    const cy = Math.floor(y / CELL);
    // map visible row to board row
    const by = cy + (ROWS - VISIBLE);
    return {cx, cy, by, pxCell: cx*CELL, pyCell: cy*CELL};
  }

  function breakBlockAt(cell){
    if(secretMode !== "LEONIS") return false;
    const {cx, by, pxCell, pyCell} = cell;
    if(cx<0 || cx>=COLS || by<0 || by>=ROWS) return false;
    if(!board[by][cx]) return false; // only break locked blocks
    // don't break current falling piece - only merged area in board
    board[by][cx] = null;
    // small score penalty to keep it fair
    score = Math.max(0, score - 25);
    updateUI();
    spawnParticles(pxCell, pyCell, "rgba(230,238,252,.85)");
    spawnParticles(pxCell, pyCell, "rgba(181,132,77,.85)");
    flashOverlay(120, "rgba(230,238,252,.06)");
    return true;
  }

  function placeBeamAt(cell){
    if(secretMode !== "LEONA") return false;
    if(leonaCharges <= 0) return false;

    const {cx, by, pxCell, pyCell} = cell;
    if(cx<0 || cx>=COLS || by<0 || by>=ROWS) return false;
    if(board[by][cx]) return false; // only empty
    // do not place in hidden rows to avoid weirdness
    if(by < (ROWS - VISIBLE)) return false;

    board[by][cx] = "BEAM"; // special
    leonaCharges--;
    // small penalty
    score = Math.max(0, score - 10);
    updateUI();
    spawnParticles(pxCell, pyCell, "rgba(242,183,5,.85)");
    flashOverlay(120, "rgba(242,183,5,.08)");
    // if this completes lines, sweep will handle & recharge
    sweep();
    return true;
  }

  /* =========================================================
     LOOP / RENDER
     ========================================================= */
  function update(time=0){
    const delta = time - lastTime;
    lastTime = time;

    if(!paused && !gameOver){
      dropCounter += delta;
      if(dropCounter > dropInterval){
        current.y++;
        if(collide(board, current)){
          current.y--;
          lockPiece();
        }
        dropCounter = 0;
      }
    }

    render(time);
    requestAnimationFrame(update);
  }

  function render(now){
    clear();
    drawBoard();

    if(!gameOver){
      const ghost = computeGhost();
      drawPiece(ghost, true);
      drawPiece(current, false);
    }

    // particles & effects
    drawParticles(now);
    drawConfetti(now);

    // overlay flash
    if(now < overlayUntil){
      ctx.save();
      ctx.fillStyle = overlayColor;
      ctx.fillRect(0,0,canvas.width,canvas.height);
      ctx.restore();
    }

    if(paused && !gameOver){
      ctx.save();
      ctx.fillStyle = "rgba(0,0,0,.55)";
      ctx.fillRect(0,0,canvas.width,canvas.height);
      ctx.fillStyle = "#e6eefc";
      ctx.font = "900 24px system-ui";
      ctx.textAlign = "center";
      ctx.fillText("PAUSE", canvas.width/2, canvas.height/2);
      ctx.font = "14px system-ui";
      ctx.fillStyle = "#9fb2d6";
      ctx.fillText("Appuie sur P pour reprendre", canvas.width/2, canvas.height/2 + 26);
      ctx.restore();
    }

    if(gameOver){
      ctx.save();
      ctx.fillStyle = "rgba(0,0,0,.65)";
      ctx.fillRect(0,0,canvas.width,canvas.height);

      ctx.fillStyle = "rgba(242,183,5,.95)";
      ctx.font = "900 22px system-ui";
      ctx.textAlign = "center";
      ctx.fillText("CHANTIER TERMINÉ !", canvas.width/2, canvas.height/2 - 18);

      ctx.fillStyle = "#e6eefc";
      ctx.font = "14px system-ui";
      ctx.fillText(`Score : ${score|0} • Lignes : ${lines|0}`, canvas.width/2, canvas.height/2 + 8);

      ctx.fillStyle = "rgba(30,79,163,.95)";
      ctx.font = "900 13px system-ui";
      ctx.fillText("R pour recommencer", canvas.width/2, canvas.height/2 + 30);

      ctx.restore();
    }
  }

  /* =========================================================
     INPUT (keyboard + touch)
     ========================================================= */
  function togglePause(){
    if(gameOver) return;
    paused = !paused;
    statusEl.textContent = paused ? "Pause." : "Repris.";
    btnPause.textContent = paused ? "Reprendre" : "Pause";
  }

  document.addEventListener('keydown', (e) => {
    if(e.code === "KeyP"){ togglePause(); return; }
    if(e.code === "KeyR"){ reset(); return; }
    if(paused || gameOver) return;

    if(e.code === "ArrowLeft"){
      current.x--;
      if(collide(board, current)) current.x++;
    } else if(e.code === "ArrowRight"){
      current.x++;
      if(collide(board, current)) current.x--;
    } else if(e.code === "ArrowDown"){
      softDrop(); dropCounter = 0;
    } else if(e.code === "ArrowUp"){
      tryRotate(1);
    } else if(e.code === "Space"){
      hardDrop(); dropCounter = 0;
    }
  });

  btnPause.addEventListener('click', togglePause);
  btnRestart.addEventListener('click', reset);

  // Touch buttons
  const tLeft = document.getElementById('tLeft');
  const tRight = document.getElementById('tRight');
  const tRotate = document.getElementById('tRotate');
  const tDown = document.getElementById('tDown');
  const tDrop = document.getElementById('tDrop');

  function safeAction(fn){
    return (e) => {
      e.preventDefault();
      if(paused || gameOver) return;
      fn();
    };
  }
  if(tLeft){
    tLeft.addEventListener('pointerdown', safeAction(()=>{ current.x--; if(collide(board,current)) current.x++; }));
    tRight.addEventListener('pointerdown', safeAction(()=>{ current.x++; if(collide(board,current)) current.x--; }));
    tRotate.addEventListener('pointerdown', safeAction(()=>{ tryRotate(1); }));
    tDown.addEventListener('pointerdown', safeAction(()=>{ softDrop(); dropCounter=0; }));
    tDrop.addEventListener('pointerdown', safeAction(()=>{ hardDrop(); dropCounter=0; }));
  }

  // Swipe/tap on canvas for mobile play (rotate = tap)
  let touchStart = null;
  let lastTap = 0;

  canvas.addEventListener('pointerdown', (e)=>{
    // long-press handler for secret actions (LEONIS/LEONA)
    // single tap = rotate; long press = secret action (if enabled)
    if(e.pointerType === "mouse") return; // mouse uses keyboard normally; still allow long press? optional
    const pt = {x:e.clientX, y:e.clientY, t: performance.now()};
    touchStart = pt;

    let fired = false;
    const timer = setTimeout(()=>{
      if(!touchStart || fired) return;
      fired = true;
      // secret action
      if(paused || gameOver) return;
      const cell = screenToCell(touchStart.x, touchStart.y);
      if(secretMode === "LEONIS"){
        breakBlockAt(cell);
      } else if(secretMode === "LEONA"){
        placeBeamAt(cell);
      }
    }, 380);

    const up = (ev)=>{
      clearTimeout(timer);
      canvas.removeEventListener('pointerup', up);
      canvas.removeEventListener('pointercancel', up);
      if(!touchStart) return;

      const dx = ev.clientX - touchStart.x;
      const dy = ev.clientY - touchStart.y;
      const adx = Math.abs(dx), ady = Math.abs(dy);
      const elapsed = performance.now() - touchStart.t;

      // If long-press fired, do not rotate
      if(fired){ touchStart = null; return; }

      if(paused || gameOver){ touchStart = null; return; }

      // swipe thresholds
      if(adx > 22 || ady > 22){
        if(adx > ady){
          // horizontal
          if(dx < 0){ current.x--; if(collide(board,current)) current.x++; }
          else { current.x++; if(collide(board,current)) current.x--; }
        }else{
          // vertical
          if(dy > 0){
            // swipe down soft drop
            softDrop(); dropCounter=0;
          } else {
            // swipe up rotate
            tryRotate(1);
          }
        }
      } else {
        // tap
        const now = performance.now();
        if(now - lastTap < 260){
          // double tap hard drop
          hardDrop(); dropCounter=0;
        } else {
          // single tap rotate
          tryRotate(1);
        }
        lastTap = now;
      }

      touchStart = null;
    };

    canvas.addEventListener('pointerup', up);
    canvas.addEventListener('pointercancel', up);
  }, {passive:false});

  /* =========================================================
     PSEUDO VALIDATION (no persistence)
     ========================================================= */
  function validatePseudo(){
    const v = (pseudoEl.value || "").trim().toUpperCase();
    // No persistence: do nothing with storage.
    // Secret modes only activate on exact match.
    if(v === "LEONIS"){
      secretMode = "LEONIS";
      leonaCharges = 0;
      statusEl.textContent = "OK.";
      flashOverlay(220, "rgba(30,79,163,.10)");
    } else if(v === "LEONA"){
      secretMode = "LEONA";
      leonaCharges = 2;
      statusEl.textContent = "OK.";
      flashOverlay(220, "rgba(242,183,5,.10)");
    } else {
      secretMode = "NONE";
      leonaCharges = 0;
      statusEl.textContent = "OK.";
    }
    // Keep the pseudo field as “validated” visually without leaking anything
    // but do NOT show mode anywhere.
    btnValidate.style.borderColor = "rgba(242,183,5,.45)";
    setTimeout(()=> btnValidate.style.borderColor="rgba(255,255,255,.14)", 450);
  }

  btnValidate.addEventListener('click', validatePseudo);
  pseudoEl.addEventListener('keydown', (e)=>{
    if(e.key === "Enter"){ validatePseudo(); pseudoEl.blur(); }
  });

  // Ensure pseudo does not stay on reload
  window.addEventListener('pageshow', ()=>{ pseudoEl.value = ""; });

  /* =========================================================
     START
     ========================================================= */
  reset();
  requestAnimationFrame(update);
})();
</script>
</body>
</html>
